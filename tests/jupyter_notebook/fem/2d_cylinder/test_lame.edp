
int n = 40;


mesh Th = square(5*n,n,[20*x,2*y-1]);
fespace Vh(Th,P1);
Vh ux,vx,uy,vy;
real sqrt2=sqrt(2.);

macro epsilon(u1,u2) [dx(u1),dy(u2),(dy(u1)+dx(u2))/sqrt2] //
macro div(u,v) ( dx(u)+dy(v) )   //

real E = 21e5, nu = 0.28, mu= E/(2*(1+nu)); 
real lambda = E*nu/((1+nu)*(1-2*nu)), f = -1;


real c1 = E*nu/((1+nu)*(1-2*nu));
real c2 = 2.*mu;
real c3 = mu;

// solve lame([ux,uy],[vx,vy]) = int2d(Th)( 
// 	lambda*div(ux,uy)*div(vx,vy) 
// 	+2.*mu*( epsilon(ux,uy)'*epsilon(vx,vy) ) ) 
//     + int2d(Th)(vy)
// 	+ on(4,ux=0,uy=0);




solve lame([ux,uy],[vx,vy]) =int2d(Th)( c1*dx(ux)*dx(vx) + c1*dx(ux)*dy(vy) ) + 
    int2d(Th)( c1*dy(uy)*dx(vx) + c1*dy(uy)*dy(vy)) + 
    int2d(Th)( c2*dx(ux)*dx(vx) + c2*dy(uy)*dy(vy)) + 
    int2d(Th)( c3*dy(ux)*dy(vx) + c3*dy(ux)*dx(vy)) + 
    int2d(Th)( c3*dx(uy)*dy(vx) + c3*dx(uy)*dx(vy)) +  
    int2d(Th)(vy) + 
    on(4,ux = 0,uy = 0);



real coef=100; 

cout<<"Hello"<<endl;
cout<<"max ux: "<<ux[].max*coef<<endl;
cout<<"min ux: "<<ux[].min*coef<<endl<<endl;

cout<<"max uy: "<<uy[].max*coef<<endl;
cout<<"min uy: "<<uy[].min*coef<<endl;

plot([ux,uy],wait=1,ps="lamevect.eps",coef=coef);

mesh th1 = movemesh(Th, [x+ux*coef, y+uy*coef]); 
uy = uy*coef;


plot(th1,uy,wait=1,ps="lamedeform.eps");


