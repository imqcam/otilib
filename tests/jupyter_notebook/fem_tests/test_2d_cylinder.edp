
int n = 40;
real ro = 2.;
real ri = 1.;


border C0(t=1., 0.){x=0; y=ri+(ro-ri)*t; label=1;}
border C1(t=pi/2., 0.){x=ri*cos(t); y=ri*sin(t); label=2;}
border C2(t=0., 1.){x=ri+(ro-ri)*t; y=0; label=3;}
border C3(t=0., pi/2.){x=ro*cos(t); y=ro*sin(t); label=4;}

real perimi = 2*pi*ri/4.;
real perimo = 2*pi*ro/4.;
//
// real h = 0.004;
real h = 0.002;
int nr = (ro-ri)/h+1;
int nro= perimo/h+1;
int nri= perimi/h+1;

real Po = 1000;
real Pi =   10;

mesh Th = buildmesh(C0(nr)+C1(nri)+C2(nr)+C3(nro));
//mesh Th = square(nr,nr);//,[(ri+(ri-ro)*x)*cos(pi*y/2.),(ri+(ri-ro)*x)*sin(pi*y/2.)]);

fespace Vh(Th,P1);



Vh xx,yy,ux,vx,uy,vy, nx, ny, uxanal, uyanal, r, ur,uranal,error, u;

//xx = x;//(ri+(ri-ro)*x)*cos(pi*y/2.)-x;
//yy = y;//(ri+(ri-ro)*x)*sin(pi*y/2.)-y;

//Th = movemesh(Th,[xx,yy]);

//xx = x;//(ri+(ri-ro)*x)*cos(pi*y/2.)-x;
//yy = y;//(ri+(ri-ro)*x)*sin(pi*y/2.)-y;

r = (sqrt(x^2+y^2));
nx = x/r;
ny = y/r;

real E = 21e5, nu = 0.28, mu= E/(2*(1+nu)); 
real c1 = E*nu/((1+nu)*(1-2*nu));
real c2 = 2.*mu;
real c3 = mu;

solve lame([ux,uy],[vx,vy], solver=Cholesky) =int2d(Th)( c1*dx(ux)*dx(vx) + c1*dx(ux)*dy(vy) ) + 
    int2d(Th)( c1*dy(uy)*dx(vx) + c1*dy(uy)*dy(vy)) + 
    int2d(Th)( c2*dx(ux)*dx(vx) + c2*dy(uy)*dy(vy)) + 
    int2d(Th)( c3*dy(ux)*dy(vx) + c3*dy(ux)*dx(vy)) + 
    int2d(Th)( c3*dx(uy)*dy(vx) + c3*dx(uy)*dx(vy)) +  
    int1d(Th,2)( -Pi*nx*vx - Pi*ny*vy ) + 
    int1d(Th,4)(  Po*nx*vx + Po*ny*vy ) + 
    on(1,ux = 0)+on(3,uy = 0);



ur = sqrt(ux^2+uy^2);

real coef=100; 

cout<<"Hello"<<endl;
//cout<<"max ux: "<<ux[].max*coef<<endl;
//cout<<"min ux: "<<ux[].min*coef<<endl<<endl;//

//cout<<"max uy: "<<uy[].max*coef<<endl;
//cout<<"min uy: "<<uy[].min*coef<<endl;//

//u = sqrt(ux^2+uy^2);
////plot([ux,uy],wait=1,ps="lamevect.eps",coef=coef);
////plot(u,wait=1);//

real A = ri^2*ro^2*(Po-Pi)/(ro^2-ri^2);
real B = (ri^2*Pi-ro^2*Po)/(ro^2-ri^2);//

r =  sqrt(x^2+y^2);
    
uranal = (1+nu)*r/E*((1-2*nu)*B-A/(r^2));
    
uxanal = uranal*x/r;
uyanal = uranal*y/r;


uranal = sqrt(uxanal^2+uyanal^2);

error = (uranal-ur)/uranal;

//u = sqrt(uxanal^2+uyanal^2);
plot(uranal,wait=1);//
plot(error,wait=1);//
//

////plot(u,wait=1);//

////plot(Th,xx,wait=1);
//// 
//// 
